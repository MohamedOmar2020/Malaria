sscurves_Test_Comp
ROC_Test_Comp <- autoplot(sscurves_Test_Comp, curvetype = c("ROC")) + labs(title = "ROC curve of the severe malaria signature") + annotate("text", x = .65, y = .25, label = paste("AUC = 0.85"), size = 3)
PRC_Test_Comp <- autoplot(sscurves_Test_Comp, curvetype = c("PRC")) + labs(title = "PRC curve of the severe malaria signature") + annotate("text", x = .65, y = .25, label = paste("AUPRC = 0.95"), size = 3)
save(ROC_Test_Comp, PRC_Test_Comp, file = "./Objs/SevereSigROC_PRC.rda")
rm(list = ls())
load("./Objs/MalariaDataGood_NCvsC.rda")
load("./Objs/PlacentalMalaria.rda")
#load("./Objs/CerebralExtraValidation2.rda")
# Quantile normalization
usedTrainMat <- normalizeBetweenArrays(mixTrainMat, method = "quantile")
usedTestMat <- normalizeBetweenArrays(mixTestMat, method = "quantile")
# Associated groups
usedTrainGroup <- mixTrainGroup
usedTestGroup <- mixTestGroup
# Transpose the matrix
PredictorData <- t(usedTrainMat)
# Bind expression with the groups
DataTrain <- cbind(PredictorData, usedTrainGroup)
DataTrain <- as.data.frame(DataTrain)
DataTrain$usedTrainGroup <- as.factor(DataTrain$usedTrainGroup)
levels(DataTrain[, "usedTrainGroup"]) <- c("nonCerebral", "cerebral")
names(DataTrain) <- make.names(names(DataTrain))
# Feature selection via RRF
lambda <- 0.8 # Both the number of features and the quality of the features are quite sensitive to lambda for RRF. A smaller lambda leads to fewer features.
# The function for bootstraping
# RF_Strap <- function(data, indices) {
#   d <- data[indices, ] # allows boot to select sample
#   rrf <- RRF(usedTrainGroup~., data = d, flagReg = 1, coefReg=lambda) # coefReg is a constant for all variables.   #either "X,as.factor(class)" or data frame like "Y~., data=data" is fine, but the later one is significantly slower.
#   TrainData <- d
#   TrainData$usedTrainGroup <- NULL
#   subsetRRF <- rrf$feaSet
#   SelFeats <- colnames(TrainData[, subsetRRF])
#   return(as.vector(SelFeats[1:30]))
# }
#
# set.seed(333)
# bootobject_Cerebral <- boot(data = DataTrain, statistic = RF_Strap, R = 100, parallel = "multicore", ncpus = 15)
#
# save(bootobject_Cerebral, file = "./Objs/bootobject_Cerebral.rda")
load("./Objs/bootobject_Cerebral.rda")
OutFeat <- bootobject_Cerebral$t
u_genes <- na.omit(unique(as.vector(as.matrix(OutFeat))))
find_gen_rep <- function(dat, gene){
# NAs create problems in the function so we substitute that with "unknown"
dat[is.na(dat)] <- "unknown"
rep_rows <- sum(apply(dat, 1,  function(x) any(x == gene)))
names(rep_rows) <- gene
as.data.frame(rep_rows)
}
list_results <- lapply(u_genes, find_gen_rep, dat = OutFeat)
sum_result <- do.call(rbind, list_results)
sum_result$Gene <- rownames(sum_result)
sum_result <- sum_result[sum_result$rep_rows >= 5, ]
Sel <- sum_result$Gene
Sel
####################################
# Frequency plot
sum_result <- sum_result[order(sum_result$rep_rows, decreasing = T), ]
usedTrainMat_Filt <- usedTrainMat[Sel, ]
usedTestMat_Filt <- usedTestMat[Sel, ]
# Transpose the matrices
PredictorData_Filt <- t(usedTrainMat_Filt)
TestingData_Filt <- t(usedTestMat_Filt)
### Sampsize
tmp <- as.vector(table(usedTrainGroup))
num_classes <- length(tmp)
min_size <- tmp[order(tmp,decreasing=FALSE)[1]]
sampsizes <- rep(min_size,num_classes)
###########################
## Explain the RF
# DataTrain <- cbind(PredictorData_Filt, usedTrainGroup)
# DataTrain <- as.data.frame(DataTrain)
# DataTrain$usedTrainGroup <- as.factor(DataTrain$usedTrainGroup)
# levels(DataTrain$usedTrainGroup) <- c("nonCerebral", "cerebral")
#
# # MAke a violin plot
# library(tidyr)
#
# X <- pivot_longer(
#   DataTrain,
#   cols = 1:28,
#   names_to = "Gene",
#   names_repair = "check_unique",
#   values_to = "Expression",
# )
#
# png(filename = "./Figs/CerebralViolinPlot.png", width = 2000, height = 1200, res = 150)
# ggplot(X,
#        aes(x = usedTrainGroup,
#            y = Expression)) +
#   geom_violin(aes(fill = usedTrainGroup),
#               scale = "count")+
#   #geom_jitter(width = 0.1, size = 0.2)+
#   facet_wrap(~Gene)
# dev.off()
#
# set.seed(333)
# tuneRF(x = PredictorData_Filt, y = usedTrainGroup, mtryStart = 1, ntreeTry = 500, stepFactor = 1, improve = 0.01, trace = F, plot = F)
#
# set.seed(333)
# RF <- randomForest(usedTrainGroup~., data = DataTrain, mtry = 1, ntree = 500, trace = F, plot = F, doBest = T, sampsize = sampsizes, importance = T)
# RF
#
# explain_forest(RF, interactions = TRUE, data = DataTrain)
################
## Build the random forest model
set.seed(333)
load("./Objs/RF_Cerebral.rda")
PredVotes_Train <- predict(RF_Cerebral, newdata = PredictorData_Filt, type = "vote")
PredResponse_Train <- predict(RF_Cerebral, PredictorData_Filt, type="response")
ROCTrain <- roc(usedTrainGroup, PredVotes_Train[,2], plot = F, print.auc = TRUE, levels = c("nonCerebral", "cerebral"), direction = "<", col = "blue", lwd = 2, grid = TRUE, auc = TRUE, ci = TRUE)
ROCTrain
confusion_test <- confusionMatrix(PredResponse_Train, usedTrainGroup, positive = "cerebral")
confusion_test
# Calculate Matthews correlation coefficient
MCC_Train <- mcc(preds = PredResponse_Train, actuals = usedTrainGroup)
MCC_Train
#################
## Predict in the testing data
PredVotes_Test <- predict(RF_Cerebral, newdata = TestingData_Filt, type = "vote")
PredResponse_Test <- predict(RF_Cerebral, TestingData_Filt, type="response")
ROCTest <- roc(usedTestGroup, PredVotes_Test[,2], plot = F, print.auc = TRUE, levels = c("nonCerebral", "cerebral"), direction = "<", col = "blue", lwd = 2, grid = TRUE, auc = TRUE, ci = TRUE)
ROCTest
### Resubstitution performance in the Test set
ConfusionTest <- confusionMatrix(PredResponse_Test, usedTestGroup, positive = "cerebral", mode = "everything")
ConfusionTest
MCC_Test <- mltools::mcc(pred = PredResponse_Test, actuals = usedTestGroup)
MCC_Test
# For ROC and PRC curves
sscurves_Test_Cerebral <- evalmod(scores = PredVotes_Test[,2], labels = usedTestGroup)
sscurves_Test_Cerebral
ROC_Test_Cerebral <- autoplot(sscurves_Test_Cerebral, curvetype = c("ROC")) + labs(title = "ROC curve of the cerebral malaria signature") + annotate("text", x = .65, y = .25, label = paste("AUC = 0.98"), size = 3)
PRC_Test_Cerebral <- autoplot(sscurves_Test_Cerebral, curvetype = c("PRC")) + labs(title = "PRC curve of the cerebral malaria signature") + annotate("text", x = .65, y = .25, label = paste("AUPRC = 0.98"), size = 3)
########################################################################
##############################################
## Make a combined figure for the paper
load("./Objs/SevereSigROC_PRC.rda")
ROC_Test_Comp$theme$plot.title$size <- 8
PRC_Test_Comp$theme$plot.title$size <- 8
ROC_Test_Cerebral$theme$plot.title$size <- 8
PRC_Test_Cerebral$theme$plot.title$size <- 8
tiff(filename = "./Figs/TwoSignaturesPerformance.tiff", width = 2500, height = 2000, res = 350)
((ROC_Test_Comp / PRC_Test_Comp + plot_layout(tag_level = "new") & theme(plot.tag = element_text(size = 12))) |
(ROC_Test_Cerebral / PRC_Test_Cerebral + plot_layout(tag_level = "new") & theme(plot.tag = element_text(size = 12)))
) +
#plot_layout(widths = c(0.4, 1)) +
plot_annotation(
title = 'The performance of the two malaria signatures in the testing data',
tag_levels = c('A', '1'),
theme = theme(plot.title = element_text(size = 12, face = "bold"))
)
dev.off()
### Load library
library(RRF)
require(limma)
library(randomForest)
library(boot)
library(patchwork)
library(ggThemeAssist)
load("./Objs/MalariaDataGood_NCvsC.rda")
load("./Objs/PlacentalMalaria.rda")
#load("./Objs/CerebralExtraValidation2.rda")
# Quantile normalization
usedTrainMat <- normalizeBetweenArrays(mixTrainMat, method = "quantile")
usedTestMat <- normalizeBetweenArrays(mixTestMat, method = "quantile")
# Associated groups
usedTrainGroup <- mixTrainGroup
usedTestGroup <- mixTestGroup
# Transpose the matrix
PredictorData <- t(usedTrainMat)
# Bind expression with the groups
DataTrain <- cbind(PredictorData, usedTrainGroup)
DataTrain <- as.data.frame(DataTrain)
DataTrain$usedTrainGroup <- as.factor(DataTrain$usedTrainGroup)
levels(DataTrain[, "usedTrainGroup"]) <- c("nonCerebral", "cerebral")
names(DataTrain) <- make.names(names(DataTrain))
# Feature selection via RRF
lambda <- 0.8 # Both the number of features and the quality of the features are quite sensitive to lambda for RRF. A smaller lambda leads to fewer features.
# The function for bootstraping
load("./Objs/bootobject_Cerebral.rda")
OutFeat <- bootobject_Cerebral$t
#####################################
## Select the most frequent features
u_genes <- na.omit(unique(as.vector(as.matrix(OutFeat))))
find_gen_rep <- function(dat, gene){
# NAs create problems in the function so we substitute that with "unknown"
dat[is.na(dat)] <- "unknown"
rep_rows <- sum(apply(dat, 1,  function(x) any(x == gene)))
names(rep_rows) <- gene
as.data.frame(rep_rows)
}
list_results <- lapply(u_genes, find_gen_rep, dat = OutFeat)
sum_result <- do.call(rbind, list_results)
sum_result$Gene <- rownames(sum_result)
sum_result <- sum_result[sum_result$rep_rows >= 5, ]
Sel <- sum_result$Gene
Sel
####################################
# Frequency plot
sum_result <- sum_result[order(sum_result$rep_rows, decreasing = T), ]
usedTrainMat_Filt <- usedTrainMat[Sel, ]
usedTestMat_Filt <- usedTestMat[Sel, ]
# Transpose the matrices
PredictorData_Filt <- t(usedTrainMat_Filt)
TestingData_Filt <- t(usedTestMat_Filt)
### Sampsize
tmp <- as.vector(table(usedTrainGroup))
num_classes <- length(tmp)
min_size <- tmp[order(tmp,decreasing=FALSE)[1]]
sampsizes <- rep(min_size,num_classes)
###########################
set.seed(333)
RF_Cerebral <- tuneRF(x = PredictorData_Filt, y = usedTrainGroup, mtryStart = 1, ntreeTry=500, stepFactor = 1, improve=0.05, trace=F, plot=F, doBest=T, sampsize = sampsizes)
RF_Cerebral
rm(list = ls())
require(switchBox)
require(Biobase)
require(limma)
require(pROC)
require(caret)
require(RColorBrewer)
require(ggplot2)
require(reshape)
require(plotROC)
library(enrichR)
library(mltools)
library(xtable)
library(dplyr)
library(superheat)
load("./Objs/KTSP_Model_Cerebral.rda")
load("./Objs/MalariaDataGood_NCvsC.rda")
# Quantile normalization
usedTrainMat <- normalizeBetweenArrays(mixTrainMat, method = "quantile")
usedTestMat <- normalizeBetweenArrays(mixTestMat, method = "quantile")
# Associated groups
usedTrainGroup <- mixTrainGroup
usedTestGroup <- mixTestGroup
# Load mechanistic pairs
Up <- c("PUM2", "SETX", "RABEP1", "ELF2", "ZNF197", "KRIT1", "EPHA4", "XRCC5", "LARP4", "SCN2B", "CDH8", "MREG", "TTC17", "THRB")
Down <- c("TRIP12", "MYH11", "ANK2", "CD53", "SPATS2L", "KPNA6", "CHRNA10", "ASB7", "C18orf8")
myTSPs <- expand.grid(Up, Down)
myTSPs <- as.matrix(myTSPs)
colnames(myTSPs) <- c("Up", "Down")
### Common genes
keepGns <- intersect(as.vector(myTSPs), rownames(usedTrainMat))
#UsedTrainMat <- UsedTrainMat[keepGns, ]
#UsedTestMat <- UsedTestMat[keepGns, ]
### For the TSP
myTSPs <- myTSPs[myTSPs[,1] %in% keepGns & myTSPs[,2] %in% keepGns , ]
ktspStatsTrainRes <- SWAP.KTSP.Statistics(inputMat = usedTrainMat, classifier = ktspPredictorRes, CombineFunc = sum)
summary(ktspStatsTrainRes$statistics)
### Threshold
thr <- coords(roc(usedTrainGroup, ktspStatsTrainRes$statistics, levels = c("nonCerebral", "cerebral"), direction = "<"), "best")["threshold"]
thr
### Print ROC curve local maximas
coords(roc(usedTrainGroup, ktspStatsTrainRes$statistics, levels = c("nonCerebral", "cerebral"), direction = "<"), "local maximas")
### Plot Curve: note that you must reorder the levels!!!
### ("good" goes first, "bad" goes second, the opposite of confusionMatrix)
ROCTrain <- roc(usedTrainGroup, ktspStatsTrainRes$statistics, plot = T, print.thres=thr$threshold, print.auc=TRUE, print.auc.col="black", ci = T, levels = c("nonCerebral", "cerebral"), direction = "<", col="blue", lwd=2, grid=TRUE, main="Mechanistic KTSP performance in the training data")
ROCTrain
### Get predictions based on best threshold from ROC curve
usedTrainPredictionRes <- SWAP.KTSP.Classify(usedTrainMat, ktspPredictorRes, DecisionFunc = function(x) sum(x) >= thr)
### Resubstitution performance in the TRAINING set
ConfusionTrain <- confusionMatrix(usedTrainPredictionRes, usedTrainGroup, positive = "cerebral", mode = "everything")
ConfusionTrain
MCC_Train <- mltools::mcc(pred = usedTrainPredictionRes, actuals = usedTrainGroup)
MCC_Train
# Put the performance metrics together
TrainPerf <- data.frame("Training" = c(ROCTrain$ci, ConfusionTrain$overall["Accuracy"], ConfusionTrain$byClass["Balanced Accuracy"], ConfusionTrain$byClass["Sensitivity"], ConfusionTrain$byClass["Specificity"], MCC_Train))
TrainPerf[1:3, ] <- TrainPerf[c(2,1,3), ]
rownames(TrainPerf) <- c("AUC", "AUC_CI_low", "AUC_CI_high", "Accuracy", "Bal.Accuracy", "Sensitivity", "Specificity", "MCC")
ktspStatsTestRes <- SWAP.KTSP.Statistics(inputMat = usedTestMat, classifier = ktspPredictorRes, CombineFunc = sum)
summary(ktspStatsTestRes$statistics)
## Plot curve
ROCTest <- roc(usedTestGroup, ktspStatsTestRes$statistics, plot = T, print.thres=thr$threshold, print.auc=TRUE, print.auc.col="black", ci = T, levels = c("nonCerebral", "cerebral"), direction = "<", col="blue", lwd=2, grid=TRUE, main= "Mechanistic KTSP using TF_MiR Gns")
ROCTest
### Get predictions based on best threshold from ROC curve
usedTestPredictionRes <- SWAP.KTSP.Classify(usedTestMat, ktspPredictorRes, DecisionFunc = function(x) sum(x) >= thr)
### Resubstitution performance in the Test set
ConfusionTest <- confusionMatrix(usedTestPredictionRes, usedTestGroup, positive = "cerebral", mode = "everything")
ConfusionTest
MCC_Test <- mltools::mcc(pred = usedTestPredictionRes, actuals = usedTestGroup)
MCC_Test
## Group the performance metrics together
TestPerf <- data.frame("Testing" = c(ROCTest$ci, ConfusionTest$overall["Accuracy"], ConfusionTest$byClass["Balanced Accuracy"], ConfusionTest$byClass["Sensitivity"], ConfusionTest$byClass["Specificity"], MCC_Test))
TestPerf[1:3, ] <- TestPerf[c(2,1,3), ]
rownames(TestPerf) <- c("AUC", "AUC_CI_low", "AUC_CI_high", "Accuracy", "Bal.Accuracy", "Sensitivity", "Specificity", "MCC")
## Group the performance metrics of the classifier in one data frame
CereberalKTSP_Perf <- cbind(TrainPerf, TestPerf)
ktspPredictorRes
set.seed(333)
ktspPredictorRes <- SWAP.Train.KTSP(
usedTrainMat, usedTrainGroup, krange=9, featureNo= featNo,
FilterFunc = SWAP.Filter.Wilcoxon, RestrictedPairs = myTSPs)
ktspPredictorRes
ktspStatsTrainRes <- SWAP.KTSP.Statistics(inputMat = usedTrainMat, classifier = ktspPredictorRes, CombineFunc = sum)
summary(ktspStatsTrainRes$statistics)
### Threshold
thr <- coords(roc(usedTrainGroup, ktspStatsTrainRes$statistics, levels = c("nonCerebral", "cerebral"), direction = "<"), "best")["threshold"]
thr
### Print ROC curve local maximas
coords(roc(usedTrainGroup, ktspStatsTrainRes$statistics, levels = c("nonCerebral", "cerebral"), direction = "<"), "local maximas")
### Plot Curve: note that you must reorder the levels!!!
### ("good" goes first, "bad" goes second, the opposite of confusionMatrix)
ROCTrain <- roc(usedTrainGroup, ktspStatsTrainRes$statistics, plot = T, print.thres=thr$threshold, print.auc=TRUE, print.auc.col="black", ci = T, levels = c("nonCerebral", "cerebral"), direction = "<", col="blue", lwd=2, grid=TRUE, main="Mechanistic KTSP performance in the training data")
ROCTrain
### Get predictions based on best threshold from ROC curve
usedTrainPredictionRes <- SWAP.KTSP.Classify(usedTrainMat, ktspPredictorRes, DecisionFunc = function(x) sum(x) >= thr)
### Resubstitution performance in the TRAINING set
ConfusionTrain <- confusionMatrix(usedTrainPredictionRes, usedTrainGroup, positive = "cerebral", mode = "everything")
ConfusionTrain
MCC_Train <- mltools::mcc(pred = usedTrainPredictionRes, actuals = usedTrainGroup)
MCC_Train
# Put the performance metrics together
TrainPerf <- data.frame("Training" = c(ROCTrain$ci, ConfusionTrain$overall["Accuracy"], ConfusionTrain$byClass["Balanced Accuracy"], ConfusionTrain$byClass["Sensitivity"], ConfusionTrain$byClass["Specificity"], MCC_Train))
TrainPerf[1:3, ] <- TrainPerf[c(2,1,3), ]
rownames(TrainPerf) <- c("AUC", "AUC_CI_low", "AUC_CI_high", "Accuracy", "Bal.Accuracy", "Sensitivity", "Specificity", "MCC")
#########################################################################
#########################################################################
### Testing
## Compute the sum and find the best threshold
ktspStatsTestRes <- SWAP.KTSP.Statistics(inputMat = usedTestMat, classifier = ktspPredictorRes, CombineFunc = sum)
summary(ktspStatsTestRes$statistics)
## Plot curve
ROCTest <- roc(usedTestGroup, ktspStatsTestRes$statistics, plot = T, print.thres=thr$threshold, print.auc=TRUE, print.auc.col="black", ci = T, levels = c("nonCerebral", "cerebral"), direction = "<", col="blue", lwd=2, grid=TRUE, main= "Mechanistic KTSP using TF_MiR Gns")
ROCTest
rm(list = ls())
load("./Objs/MalariaDataGood_NCvsC.rda")
# Quantile normalization
usedTrainMat <- normalizeBetweenArrays(mixTrainMat, method = "quantile")
usedTestMat <- normalizeBetweenArrays(mixTestMat, method = "quantile")
# Associated groups
usedTrainGroup <- mixTrainGroup
usedTestGroup <- mixTestGroup
# Load mechanistic pairs
Up <- c("PUM2", "SETX", "RABEP1", "ELF2", "ZNF197", "KRIT1", "EPHA4", "XRCC5", "LARP4", "SCN2B", "CDH8", "MREG", "TTC17", "THRB")
Down <- c("TRIP12", "MYH11", "ANK2", "CD53", "SPATS2L", "KPNA6", "CHRNA10", "ASB7", "C18orf8")
myTSPs <- expand.grid(Up, Down)
myTSPs <- as.matrix(myTSPs)
colnames(myTSPs) <- c("Up", "Down")
### Common genes
keepGns <- intersect(as.vector(myTSPs), rownames(usedTrainMat))
#UsedT
### For the TSP
myTSPs <- myTSPs[myTSPs[,1] %in% keepGns & myTSPs[,2] %in% keepGns , ]
ktsp <- c(3:25) #8
featNo <- nrow(usedTrainMat)
### Train a classifier using default filtering function based on Wilcoxon
set.seed(333)
ktspPredictorRes <- SWAP.Train.KTSP(
usedTrainMat, usedTrainGroup, krange=9, featureNo= featNo,
FilterFunc = SWAP.Filter.Wilcoxon, RestrictedPairs = myTSPs)
ktspPredictorRes
ktspStatsTrainRes <- SWAP.KTSP.Statistics(inputMat = usedTrainMat, classifier = ktspPredictorRes, CombineFunc = sum)
summary(ktspStatsTrainRes$statistics)
### Threshold
thr <- coords(roc(usedTrainGroup, ktspStatsTrainRes$statistics, levels = c("nonCerebral", "cerebral"), direction = "<"), "best")["threshold"]
thr
### Print ROC curve local maximas
coords(roc(usedTrainGroup, ktspStatsTrainRes$statistics, levels = c("nonCerebral", "cerebral"), direction = "<"), "local maximas")
### Plot Curve: note that you must reorder the levels!!!
### ("good" goes first, "bad" goes second, the opposite of confusionMatrix)
ROCTrain <- roc(usedTrainGroup, ktspStatsTrainRes$statistics, plot = T, print.thres=thr$threshold, print.auc=TRUE, print.auc.col="black", ci = T, levels = c("nonCerebral", "cerebral"), direction = "<", col="blue", lwd=2, grid=TRUE, main="Mechanistic KTSP performance in the training data")
ROCTrain
usedTrainPredictionRes <- SWAP.KTSP.Classify(usedTrainMat, ktspPredictorRes, DecisionFunc = function(x) sum(x) >= thr)
### Resubstitution performance in the TRAINING set
ConfusionTrain <- confusionMatrix(usedTrainPredictionRes, usedTrainGroup, positive = "cerebral", mode = "everything")
ConfusionTrain
MCC_Train <- mltools::mcc(pred = usedTrainPredictionRes, actuals = usedTrainGroup)
MCC_Train
# Put the performance metrics together
TrainPerf <- data.frame("Training" = c(ROCTrain$ci, ConfusionTrain$overall["Accuracy"], ConfusionTrain$byClass["Balanced Accuracy"], ConfusionTrain$byClass["Sensitivity"], ConfusionTrain$byClass["Specificity"], MCC_Train))
TrainPerf[1:3, ] <- TrainPerf[c(2,1,3), ]
rownames(TrainPerf) <- c("AUC", "AUC_CI_low", "AUC_CI_high", "Accuracy", "Bal.Accuracy", "Sensitivity", "Specificity", "MCC")
#########################################################################
#########################################################################
### Testing
## Compute the sum and find the best threshold
ktspStatsTestRes <- SWAP.KTSP.Statistics(inputMat = usedTestMat, classifier = ktspPredictorRes, CombineFunc = sum)
summary(ktspStatsTestRes$statistics)
## Plot curve
ROCTest <- roc(usedTestGroup, ktspStatsTestRes$statistics, plot = T, print.thres=thr$threshold, print.auc=TRUE, print.auc.col="black", ci = T, levels = c("nonCerebral", "cerebral"), direction = "<", col="blue", lwd=2, grid=TRUE, main= "Mechanistic KTSP using TF_MiR Gns")
ROCTest
### Get predictions based on best threshold from ROC curve
usedTestPredictionRes <- SWAP.KTSP.Classify(usedTestMat, ktspPredictorRes, DecisionFunc = function(x) sum(x) >= thr)
### Resubstitution performance in the Test set
ConfusionTest <- confusionMatrix(usedTestPredictionRes, usedTestGroup, positive = "cerebral", mode = "everything")
ConfusionTest
MCC_Test <- mltools::mcc(pred = usedTestPredictionRes, actuals = usedTestGroup)
MCC_Test
## Group the performance metrics together
TestPerf <- data.frame("Testing" = c(ROCTest$ci, ConfusionTest$overall["Accuracy"], ConfusionTest$byClass["Balanced Accuracy"], ConfusionTest$byClass["Sensitivity"], ConfusionTest$byClass["Specificity"], MCC_Test))
TestPerf[1:3, ] <- TestPerf[c(2,1,3), ]
rownames(TestPerf) <- c("AUC", "AUC_CI_low", "AUC_CI_high", "Accuracy", "Bal.Accuracy", "Sensitivity", "Specificity", "MCC")
## Group the performance metrics of the classifier in one data frame
CereberalKTSP_Perf <- cbind(TrainPerf, TestPerf)
forLegend_KTSP <- apply(rbind(
ci(roc(usedTrainGroup, ktspStatsTrainRes$statistics, levels = c("nonCerebral", "cerebral"), direction = "<")),
ci(roc(usedTestGroup, ktspStatsTestRes$statistics, levels = c("nonCerebral", "cerebral"), direction = "<"))
),  1, function(x) {
x <- format(round(x, digits=2), nsmall=2)
paste("AUC: ", x[[2]], ";", "95% CI: ", x[[1]], "-", x[[3]])
})
#################################################################
### ROC curves Using ggplot2
### Training
datTrn_KTSP <- melt(data.frame(
## Training Group
Training=factor(usedTrainGroup, levels = c("nonCerebral", "cerebral")),
## Mechanistic KTSP SUM training
KTSP.Training=ktspStatsTrainRes$statistics))
### Change Colnames
colnames(datTrn_KTSP) <- c("Status", "KTSP_type", "KTSP_sum")
### Testing
datTst_KTSP <- melt(data.frame(
## Testing group
Testing=factor(usedTestGroup, levels = c("nonCerebral", "cerebral")),
## Mechanistic KTSP SUM training
KTSP.Testing=ktspStatsTestRes$statistics))
### Change Colnames
colnames(datTst_KTSP) <- c("Status", "KTSP_type", "KTSP_sum")
### Combine
dat_KTSP <- rbind(datTrn_KTSP, datTst_KTSP)
dat_KTSP$Status <- as.numeric(dat_KTSP$Status)-1
### Replace levels
levels(dat_KTSP$KTSP_type) <- gsub("\\.", "-", levels(dat_KTSP$KTSP_type))
levels(dat_KTSP$KTSP_type) <- paste(levels(dat_KTSP$KTSP_type), forLegend_KTSP[c(1,2)])
tiff("./Figs/AUCggplot_Cerebral.tiff",
width=3000, height=3000, res=300)
### Color
myCol <- brewer.pal(3, "Dark2")[c(2,1)]
### Plot and legend titles
plotTitle <- "Performance of the 9-TSPs cerebral malaria signature in the training and testing data"
#legendTitle <- paste("Mechanistic (", nrow(ktspPredictorRes$TSPs), " pairs)",
#                     "Agnostic (", nrow(ktspPredictorUnRes$TSPs), " pairs)",  sep="")
### Plot
basicplot_KTSP <- ggplot(dat_KTSP, aes(d=Status, m=KTSP_sum, color=KTSP_type,
linetype = KTSP_type)) +
geom_roc(cutoffs.at = seq(1,20,1)) +
style_roc(theme = theme_grey) + ggtitle(plotTitle) +
theme(plot.title = element_text(face="bold", size=14, hjust = 0.5),
axis.text=element_text(face="plain", size = 11),
axis.title=element_text(face="bold", size = 13),
legend.justification=c(1,0),  legend.position=c(1,0),
legend.background=element_rect(fill="lightblue1"),
legend.text=element_text(face="plain", size = 14),
legend.title = element_text(face="bold", size=0)) +
#scale_color_manual(legendTitle, values=rep(myCol, 2)) +
#scale_linetype_manual(legendTitle, values=rep(c("solid", "dotted"), each=2)) +
guides(colour = guide_legend(override.aes = list(size=3)))
### Plot
basicplot_KTSP
### Close device
dev.off()
save(basicplot_KTSP, file = "./Objs/BasicPlot_KTSP_Cerebral.rda")
tiff("./Figs/AUCggplot_Cerebral.tiff",
width=2500, height=2500, res=300)
### Color
myCol <- brewer.pal(3, "Dark2")[c(2,1)]
### Plot and legend titles
plotTitle <- "Performance of the 9-TSPs cerebral malaria signature in the training and testing data"
#legendTitle <- paste("Mechanistic (", nrow(ktspPredictorRes$TSPs), " pairs)",
#                     "Agnostic (", nrow(ktspPredictorUnRes$TSPs), " pairs)",  sep="")
### Plot
basicplot_KTSP <- ggplot(dat_KTSP, aes(d=Status, m=KTSP_sum, color=KTSP_type,
linetype = KTSP_type)) +
geom_roc(cutoffs.at = seq(1,20,1)) +
style_roc(theme = theme_grey) + ggtitle(plotTitle) +
theme(plot.title = element_text(face="bold", size=14, hjust = 0.5),
axis.text=element_text(face="plain", size = 11),
axis.title=element_text(face="bold", size = 13),
legend.justification=c(1,0),  legend.position=c(1,0),
legend.background=element_rect(fill="lightblue1"),
legend.text=element_text(face="plain", size = 14),
legend.title = element_text(face="bold", size=0)) +
#scale_color_manual(legendTitle, values=rep(myCol, 2)) +
#scale_linetype_manual(legendTitle, values=rep(c("solid", "dotted"), each=2)) +
guides(colour = guide_legend(override.aes = list(size=3)))
### Plot
basicplot_KTSP
### Close device
dev.off()
save(basicplot_KTSP, file = "./Objs/BasicPlot_KTSP_Cerebral.rda")
tiff("./Figs/AUCggplot_Cerebral.tiff",
width=2800, height=2500, res=300)
### Color
myCol <- brewer.pal(3, "Dark2")[c(2,1)]
### Plot and legend titles
plotTitle <- "Performance of the 9-TSPs cerebral malaria signature in the training and testing data"
#legendTitle <- paste("Mechanistic (", nrow(ktspPredictorRes$TSPs), " pairs)",
#                     "Agnostic (", nrow(ktspPredictorUnRes$TSPs), " pairs)",  sep="")
### Plot
basicplot_KTSP <- ggplot(dat_KTSP, aes(d=Status, m=KTSP_sum, color=KTSP_type,
linetype = KTSP_type)) +
geom_roc(cutoffs.at = seq(1,20,1)) +
style_roc(theme = theme_grey) + ggtitle(plotTitle) +
theme(plot.title = element_text(face="bold", size=14, hjust = 0.5),
axis.text=element_text(face="plain", size = 11),
axis.title=element_text(face="bold", size = 13),
legend.justification=c(1,0),  legend.position=c(1,0),
legend.background=element_rect(fill="lightblue1"),
legend.text=element_text(face="plain", size = 14),
legend.title = element_text(face="bold", size=0)) +
#scale_color_manual(legendTitle, values=rep(myCol, 2)) +
#scale_linetype_manual(legendTitle, values=rep(c("solid", "dotted"), each=2)) +
guides(colour = guide_legend(override.aes = list(size=3)))
### Plot
basicplot_KTSP
### Close device
dev.off()
save(basicplot_KTSP, file = "./Objs/BasicPlot_KTSP_Cerebral.rda")
##################################################################################################
