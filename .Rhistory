# ffun <- filterfun(pOverA(p = 0.5, A = 100))
# filt3 <- genefilter(2^X3,ffun)
# expr9 <- expr9[filt3,]
# dim(expr9)
#
expr9 <- t(scale(t(expr9), center = TRUE, scale = TRUE))
# Pheno1
pheno1 <- pheno1[!(pheno1$`diesease status:ch1` == "healthy"), ]
pheno1$DiseaseStatus <- as.factor(pheno1$`diesease status:ch1`)
levels(pheno1$DiseaseStatus)
expr1 <- expr1[, colnames(expr1) %in% rownames(pheno1)]
all(rownames(pheno1) == colnames(expr1))
# Pheno2
pheno2 <- pheno2[!(pheno2$`diesease status:ch1` == "healthy"), ]
pheno2$DiseaseStatus <- as.factor(pheno2$`diesease status:ch1`)
levels(pheno2$DiseaseStatus)
expr2 <- expr2[, colnames(expr2) %in% rownames(pheno2)]
all(rownames(pheno2) == colnames(expr2))
# Pheno3
pheno3 <- pheno3[!(pheno3$`diagnosis:ch1` == "no Plasmodium falciparum infection"), ]
pheno3$DiseaseStatus <- as.factor(pheno3$`diagnosis:ch1`)
levels(pheno3$DiseaseStatus)
expr3 <- expr3[, colnames(expr3) %in% rownames(pheno3)]
all(rownames(pheno3) == colnames(expr3))
# Pheno4
pheno4 <- pheno4[!(pheno4$`disease state:ch2` == "Healthy"), ]
pheno4$DiseaseStatus <- as.factor(pheno4$`disease state:ch2`)
levels(pheno4$DiseaseStatus)
expr4 <- expr4[, colnames(expr4) %in% rownames(pheno4)]
all(rownames(pheno4) == colnames(expr4))
# Pheno5
# This dataset is not clear about the complication status >> use parasitemia
pheno5 <- pheno5[!(pheno5$source_name_ch1 == "Whole blood, age-matched control"), ]
pheno5$DiseaseStatus <- as.factor(pheno5$`parasitemia category:ch1`)
levels(pheno5$DiseaseStatus)
levels(pheno5$DiseaseStatus) <- c("Complicated", "unComplicated")
table(pheno5$DiseaseStatus)
View(pheno5)
expr5 <- expr5[, colnames(expr5) %in% rownames(pheno5)]
all(rownames(pheno5) == colnames(expr5))
# Pheno6
pheno6$DiseaseStatus <- as.factor(pheno6$`disease state:ch1`)
levels(pheno6$DiseaseStatus)
View(pheno5)
# Pheno7
# Use parasitemia
pheno7 <- pheno7[!(pheno7$`subject status:ch1` == "normal, healthy subject"), ]
pheno7$DiseaseStatus
View(pheno7)
levels(pheno7$DiseaseStatus) <- c("Complicated", "unComplicated")
pheno7$DiseaseStatus <- c("unComplicated", "unComplicated", "unComplicated", "Complicated", "Complicated", "Complicated")
pheno7$DiseaseStatus <- as.factor(pheno7$DiseaseStatus)
levels(pheno7$DiseaseStatus) <- c("Complicated", "unComplicated")
table(pheno7$DiseaseStatus)
expr7 <- expr7[, colnames(expr7) %in% rownames(pheno7)]
all(rownames(pheno7) == colnames(expr7))
# Pheno8
pheno8 <- pheno8[pheno8$`disease group:ch1` == "Malaria", ]
pheno8$DiseaseStatus <- as.factor(pheno8$`disease group:ch1`)
levels(pheno8$DiseaseStatus)
View(pheno8)
table(pheno8$DiseaseStatus)
expr8 <- expr8[, colnames(expr8) %in% rownames(pheno8)]
all(rownames(pheno8) == colnames(expr8))
# Pheno9
pheno9$DiseaseStatus <- rep("Complicated", nrow(pheno9))
table(pheno9$DiseaseStatus)
table(pheno5$`parasitemia category:ch1`)
View(pheno5)
111/1000
rm(list = ls())
library(RRF)
require(limma)
library(randomForest)
library(boot)
library(precrec)
library(pheatmap)
library(randomForestExplainer)
library(inTrees)
library(pROC)
library(caret)
## Load data
load("./Objs/MalariaDataGood_Comp.rda")
load("./Objs/PlacentalMalaria.rda")
load("./Objs/ExtraMalaria.rda")
# Quantile normalization
usedTrainMat <- normalizeBetweenArrays(mixTrainMat, method = "quantile")
usedTestMat <- normalizeBetweenArrays(mixTestMat, method = "quantile")
# Associated groups
usedTrainGroup <- mixTrainGroup
usedTestGroup <- mixTestGroup
# Transpose the matrix
PredictorData <- t(usedTrainMat)
# Bind expression with the groups
DataTrain <- cbind(PredictorData, usedTrainGroup)
DataTrain <- as.data.frame(DataTrain)
DataTrain$usedTrainGroup <- as.factor(DataTrain$usedTrainGroup)
levels(DataTrain[, "usedTrainGroup"]) <- c("unComplicated", "Complicated")
names(DataTrain) <- make.names(names(DataTrain))
# Feature selection via RRF
lambda <- 0.8 # Both the number of features and the quality of the features are quite sensitive to lambda for RRF. A smaller lambda leads to fewer features.
# The function for bootstraping
# RF_Strap <- function(data, indices) {
#   d <- data[indices, ] # allows boot to select sample
#   rrf <- RRF(usedTrainGroup~., data = d, flagReg = 1, coefReg=lambda) # coefReg is a constant for all variables.   #either "X,as.factor(class)" or data frame like "Y~., data=data" is fine, but the later one is significantly slower.
#   TrainData <- d
#   TrainData$usedTrainGroup <- NULL
#   subsetRRF <- rrf$feaSet
#   SelFeats <- colnames(TrainData[, subsetRRF])
#   return(as.vector(SelFeats[1:30]))
# }
#
# set.seed(333)
# bootobject_Comp <- boot(data = DataTrain, statistic = RF_Strap, R = 100, parallel = "multicore", ncpus = 15)
#
#
# save(bootobject_Comp, file = "./Objs/bootobject_Comp.rda")
load("./Objs/bootobject_Comp.rda")
OutFeat <- bootobject_Comp$t
#####################################
## Select the most frequent features
u_genes <- na.omit(unique(as.vector(as.matrix(OutFeat))))
find_gen_rep <- function(dat, gene){
# NAs create problems in the function so we substitute that with "unknown"
dat[is.na(dat)] <- "unknown"
rep_rows <- sum(apply(dat, 1,  function(x) any(x == gene)))
names(rep_rows) <- gene
as.data.frame(rep_rows)
}
list_results <- lapply(u_genes, find_gen_rep, dat = OutFeat)
sum_result <- do.call(rbind, list_results)
sum_result$Gene <- rownames(sum_result)
sum_result <- sum_result[sum_result$rep_rows >= 5, ]
Sel <- sum_result$Gene
Sel
####################################
# Frequency figure
# sum_result <- sum_result[order(sum_result$rep_rows, decreasing = T), ]
#
# png(filename = "./Figs/CompFrequency.png", width = 2000, height = 2000, res = 300)
# CompFreq <- ggplot(data=sum_result, aes(x=rep_rows, y=reorder(Gene, rep_rows))) +
#   geom_col(width=0.5) +
#   scale_x_continuous(limits = c(0,15), breaks = 0:15) +
#   labs(y = "Gene", x = "Frequency", title = " Frequency of genes in the severe malaria signature")
# CompFreq
# dev.off()
##################
# Together with cerebral signature
# load("./Objs/CerebralFreqPlot.png")
#
# png(filename = "./Figs/CombinedFrequency.png", width = 3000, height = 1700, res = 200)
# CompFreq + CerebralFreq
# dev.off()
########################################
## Heatmap
# NewOrder <- order(usedTrainGroup)
# usedTrainGroup_ord <- usedTrainGroup[NewOrder]
#
# X <- usedTrainMat[Sel, ]
#
# X <- X[, NewOrder]
#
# Annot <- as.data.frame(usedTrainGroup_ord)
# rownames(Annot) <- names(usedTrainGroup_ord)
#
# png(filename = "./Figs/CompHeatmap.png", width = 2000, height = 1500, res = 300)
# pheatmap::pheatmap(X, annotation_col = Annot, cluster_cols = F, cluster_rows = F, show_colnames = F)
# dev.off()
#####################################
## Use the selected features to build a new random forest model
usedTrainMat_Filt <- usedTrainMat[Sel, ]
usedTestMat_Filt <- usedTestMat[Sel, ]
# Transpose the matrices
PredictorData_Filt <- t(usedTrainMat_Filt)
TestingData_Filt <- t(usedTestMat_Filt)
### Sampsize
tmp <- as.vector(table(usedTrainGroup))
num_classes <- length(tmp)
min_size <- tmp[order(tmp,decreasing=FALSE)[1]]
sampsizes <- rep(min_size,num_classes)
###########################
## Explain the RF
# DataTrain <- cbind(PredictorData_Filt, usedTrainGroup)
# DataTrain <- as.data.frame(DataTrain)
# DataTrain$usedTrainGroup <- as.factor(DataTrain$usedTrainGroup)
# levels(DataTrain$usedTrainGroup) <- c("unComplicated", "Complicated")
#
# # MAke a violin plot
# library(tidyr)
#
# X <- pivot_longer(
#   DataTrain,
#   cols = 1:28,
#   names_to = "Gene",
#   names_repair = "check_unique",
#   values_to = "Expression",
# )
#
# png(filename = "./Figs/ComViolinPlot.png", width = 2000, height = 1200, res = 150)
# ggplot(X,
#        aes(x = usedTrainGroup,
#            y = Expression)) +
#   geom_violin(aes(fill = usedTrainGroup),
#               scale = "count")+
#   #geom_jitter(width = 0.1, size = 0.2)+
#   facet_wrap(~Gene)
# dev.off()
# set.seed(333)
# tuneRF(x = PredictorData_Filt, y = usedTrainGroup, mtryStart = 1, ntreeTry = 500, stepFactor = 1, improve = 0.01, trace = F, plot = F)
#
# set.seed(333)
# RF <- randomForest(usedTrainGroup~., data = DataTrain, mtry = 1, ntree = 500, trace = F, plot = F, doBest = T, sampsize = sampsizes, importance = T)
# RF
#
# explain_forest(RF, interactions = TRUE, data = DataTrain)
##################################
## Build the random forest model
set.seed(333)
RF_Comp <- tuneRF(x = PredictorData_Filt, y = usedTrainGroup, mtryStart = 1, ntreeTry=500, stepFactor = 1, improve=0.05, trace=F, plot=F, doBest=T, sampsize = sampsizes)
RF_Comp
# treeList <- RF2List(RF_Comp)  # transform rf object to an inTrees' format
# exec <- extractRules(treeList, PredictorData_Filt)  # R-executable conditions
# exec[1:2,]
#
# ruleMetric <- getRuleMetric(exec,PredictorData_Filt,usedTrainGroup)  # get rule metrics
# ruleMetric[1:2,]
#
# readableRules <- presentRules(ruleMetric, colnames(PredictorData_Filt))
# readableRules[1:2, ]
#
# freqPattern <- getFreqPattern(ruleMetric)
# Save the model
#save(RF_Comp, file = "./Objs/RF_Comp.rda")
load("./Objs/RF_Comp.rda")
################
# Predict in the training data
PredVotes_Train <- predict(RF_Comp, newdata = PredictorData_Filt, type = "vote")
PredResponse_Train <- predict(RF_Comp, PredictorData_Filt, type="response")
ROCTrain <- roc(usedTrainGroup, PredVotes_Train[,2], plot = F, print.auc = TRUE, levels = c("unComplicated", "Complicated"), direction = "<", col = "blue", lwd = 2, grid = TRUE, auc = TRUE, ci = TRUE)
ROCTrain
confusion_test <- confusionMatrix(PredResponse_Train, usedTrainGroup, positive = "Complicated")
confusion_test
# Calculate Matthews correlation coefficient
MCC_Train <- mcc(preds = PredResponse_Train, actuals = usedTrainGroup)
MCC_Train
#################
## Predict in the testing data
PredVotes_Test <- predict(RF_Comp, newdata = TestingData_Filt, type = "vote")
PredResponse_Test <- predict(RF_Comp, TestingData_Filt, type="response")
ROCTest <- roc(usedTestGroup, PredVotes_Test[,2], plot = F, print.auc = TRUE, levels = c("unComplicated", "Complicated"), direction = "<", col = "blue", lwd = 2, grid = TRUE, auc = TRUE, ci = TRUE)
ROCTest
Sel
rm(list = ls())
## Load data
load("./Objs/MalariaDataGood_NCvsC.rda")
load("./Objs/PlacentalMalaria.rda")
#load("./Objs/CerebralExtraValidation2.rda")
# Quantile normalization
usedTrainMat <- normalizeBetweenArrays(mixTrainMat, method = "quantile")
usedTestMat <- normalizeBetweenArrays(mixTestMat, method = "quantile")
# Associated groups
usedTrainGroup <- mixTrainGroup
usedTestGroup <- mixTestGroup
# Transpose the matrix
PredictorData <- t(usedTrainMat)
# Bind expression with the groups
DataTrain <- cbind(PredictorData, usedTrainGroup)
DataTrain <- as.data.frame(DataTrain)
DataTrain$usedTrainGroup <- as.factor(DataTrain$usedTrainGroup)
levels(DataTrain[, "usedTrainGroup"]) <- c("nonCerebral", "cerebral")
names(DataTrain) <- make.names(names(DataTrain))
# Feature selection via RRF
lambda <- 0.8 # Both the number of features and the quality of the features are quite sensitive to lambda for RRF. A smaller lambda leads to fewer features.
# The function for bootstraping
# RF_Strap <- function(data, indices) {
#   d <- data[indices, ] # allows boot to select sample
#   rrf <- RRF(usedTrainGroup~., data = d, flagReg = 1, coefReg=lambda) # coefReg is a constant for all variables.   #either "X,as.factor(class)" or data frame like "Y~., data=data" is fine, but the later one is significantly slower.
#   TrainData <- d
#   TrainData$usedTrainGroup <- NULL
#   subsetRRF <- rrf$feaSet
#   SelFeats <- colnames(TrainData[, subsetRRF])
#   return(as.vector(SelFeats[1:30]))
# }
#
# set.seed(333)
# bootobject_Cerebral <- boot(data = DataTrain, statistic = RF_Strap, R = 100, parallel = "multicore", ncpus = 15)
#
# save(bootobject_Cerebral, file = "./Objs/bootobject_Cerebral.rda")
load("./Objs/bootobject_Cerebral.rda")
OutFeat <- bootobject_Cerebral$t
#####################################
## Select the most frequent features
u_genes <- na.omit(unique(as.vector(as.matrix(OutFeat))))
find_gen_rep <- function(dat, gene){
# NAs create problems in the function so we substitute that with "unknown"
dat[is.na(dat)] <- "unknown"
rep_rows <- sum(apply(dat, 1,  function(x) any(x == gene)))
names(rep_rows) <- gene
as.data.frame(rep_rows)
}
list_results <- lapply(u_genes, find_gen_rep, dat = OutFeat)
sum_result <- do.call(rbind, list_results)
sum_result$Gene <- rownames(sum_result)
sum_result <- sum_result[sum_result$rep_rows >= 5, ]
Sel <- sum_result$Gene
Sel
########################################
## Heatmap
NewOrder <- order(usedTrainGroup)
usedTrainGroup_ord <- usedTrainGroup[NewOrder]
#
X <- usedTrainMat[Sel, ]
#
X <- X[, NewOrder]
#
Annot <- as.data.frame(usedTrainGroup_ord)
rownames(Annot) <- names(usedTrainGroup_ord)
#
# png(filename = "./Figs/CerebralHeatmap.png", width = 2000, height = 1500, res = 300)
pheatmap::pheatmap(X, annotation_col = Annot, cluster_cols = F, cluster_rows = F, show_colnames = F)
GenesOrdered <- c("PUM2", "SETX", "RABEP1", "ELF2", "MORC2", "ZNF197", "KRIT1", "EPHA4", "USP34", "OGT", "XRCC5", "LARP4", "SCN2B", "CDH8", "VPS13B", "PPP6R3", "MREG", "TTC17", "THRB", "ATP5G3", "TRIP12", "MYH11", "ANK2", "CD53", "MAP3K13", "PGR", "DGKQ", "SPATS2L", "KPNA6", "CHRNA10", "ASB7", "C18orf8")
#
X <- X[GenesOrdered, NewOrder]
#
Annot <- as.data.frame(usedTrainGroup_ord)
rownames(Annot) <- names(usedTrainGroup_ord)
#
# png(filename = "./Figs/CerebralHeatmap.png", width = 2000, height = 1500, res = 300)
pheatmap::pheatmap(X, annotation_col = Annot, cluster_cols = F, cluster_rows = F, show_colnames = F)
########################################
## Heatmap
NewOrder <- order(usedTrainGroup)
usedTrainGroup_ord <- usedTrainGroup[NewOrder]
GenesOrdered <- c("PUM2", "SETX", "RABEP1", "ELF2", "MORC2", "ZNF197", "KRIT1", "EPHA4", "USP34", "OGT", "XRCC5", "LARP4", "SCN2B", "CDH8", "VPS13B", "PPP6R3", "MREG", "TTC17", "THRB", "ATP5G3", "TRIP12", "MYH11", "ANK2", "CD53", "MAP3K13", "PGR", "DGKQ", "SPATS2L", "KPNA6", "CHRNA10", "ASB7", "C18orf8")
X <- usedTrainMat[Sel, ]
#
X <- X[GenesOrdered, NewOrder]
#
Annot <- as.data.frame(usedTrainGroup_ord)
rownames(Annot) <- names(usedTrainGroup_ord)
#
# png(filename = "./Figs/CerebralHeatmap.png", width = 2000, height = 1500, res = 300)
pheatmap::pheatmap(X, annotation_col = Annot, cluster_cols = F, cluster_rows = F, show_colnames = F)
#
png(filename = "./Figs/CerebralHeatmap.png", width = 2000, height = 1500, res = 300)
pheatmap::pheatmap(X, annotation_col = Annot, cluster_cols = F, cluster_rows = F, show_colnames = F)
dev.off()
#
png(filename = "./Figs/CerebralHeatmap.png", width = 2000, height = 1500, res = 300)
pheatmap::pheatmap(X, annotation_col = Annot, cluster_cols = F, cluster_rows = F, show_colnames = F)
dev.off()
#
png(filename = "./Figs/CerebralHeatmap.png", width = 2000, height = 1500, res = 300)
pheatmap::pheatmap(X, annotation_col = Annot, cluster_cols = F, cluster_rows = F, show_colnames = F)
dev.off()
graphics.off()
#
png(filename = "./Figs/CerebralHeatmap.png", width = 2000, height = 1500, res = 300)
pheatmap::pheatmap(X, annotation_col = Annot, cluster_cols = F, cluster_rows = F, show_colnames = F)
dev.off()
png(filename = "./Figs/CerebralHeatmap.png", width = 2000, height = 1500, res = 300)
pheatmap::pheatmap(X, annotation_col = Annot, cluster_cols = F, cluster_rows = F, show_colnames = F)
dev.off()
#############
pheatmap::pheatmap(X, annotation_col = Annot, cluster_cols = F, cluster_rows = F, show_colnames = F)
#
png(filename = "./Figs/CerebralHeatmap.png", width = 2000, height = 1500, res = 300)
pheatmap::pheatmap(X, annotation_col = Annot, cluster_cols = F, cluster_rows = F, show_colnames = F)
dev.off()
rm(list = ls())
load("./Objs/MalariaDataGood_Comp.rda")
load("./Objs/PlacentalMalaria.rda")
load("./Objs/ExtraMalaria.rda")
# Quantile normalization
usedTrainMat <- normalizeBetweenArrays(mixTrainMat, method = "quantile")
usedTestMat <- normalizeBetweenArrays(mixTestMat, method = "quantile")
# Associated groups
usedTrainGroup <- mixTrainGroup
usedTestGroup <- mixTestGroup
# Transpose the matrix
PredictorData <- t(usedTrainMat)
# Bind expression with the groups
DataTrain <- cbind(PredictorData, usedTrainGroup)
DataTrain <- as.data.frame(DataTrain)
DataTrain$usedTrainGroup <- as.factor(DataTrain$usedTrainGroup)
levels(DataTrain[, "usedTrainGroup"]) <- c("unComplicated", "Complicated")
names(DataTrain) <- make.names(names(DataTrain))
# Feature selection via RRF
lambda <- 0.8 # Both the number of features and the quality of the features are quite sensitive to lambda for RRF. A smaller lambda leads to fewer features.
# The function for bootstraping
# RF_Strap <- function(data, indices) {
#   d <- data[indices, ] # allows boot to select sample
#   rrf <- RRF(usedTrainGroup~., data = d, flagReg = 1, coefReg=lambda) # coefReg is a constant for all variables.   #either "X,as.factor(class)" or data frame like "Y~., data=data" is fine, but the later one is significantly slower.
#   TrainData <- d
#   TrainData$usedTrainGroup <- NULL
#   subsetRRF <- rrf$feaSet
#   SelFeats <- colnames(TrainData[, subsetRRF])
#   return(as.vector(SelFeats[1:30]))
# }
#
# set.seed(333)
# bootobject_Comp <- boot(data = DataTrain, statistic = RF_Strap, R = 100, parallel = "multicore", ncpus = 15)
#
#
# save(bootobject_Comp, file = "./Objs/bootobject_Comp.rda")
load("./Objs/bootobject_Comp.rda")
OutFeat <- bootobject_Comp$t
#####################################
## Select the most frequent features
u_genes <- na.omit(unique(as.vector(as.matrix(OutFeat))))
find_gen_rep <- function(dat, gene){
# NAs create problems in the function so we substitute that with "unknown"
dat[is.na(dat)] <- "unknown"
rep_rows <- sum(apply(dat, 1,  function(x) any(x == gene)))
names(rep_rows) <- gene
as.data.frame(rep_rows)
}
list_results <- lapply(u_genes, find_gen_rep, dat = OutFeat)
sum_result <- do.call(rbind, list_results)
sum_result$Gene <- rownames(sum_result)
sum_result <- sum_result[sum_result$rep_rows >= 5, ]
Sel <- sum_result$Gene
Sel
usedTrainMat_Filt <- usedTrainMat[Sel, ]
usedTestMat_Filt <- usedTestMat[Sel, ]
# Transpose the matrices
PredictorData_Filt <- t(usedTrainMat_Filt)
TestingData_Filt <- t(usedTestMat_Filt)
### Sampsize
tmp <- as.vector(table(usedTrainGroup))
num_classes <- length(tmp)
min_size <- tmp[order(tmp,decreasing=FALSE)[1]]
sampsizes <- rep(min_size,num_classes)
###########################
## Explain the RF
# DataTrain <- cbind(PredictorData_Filt, usedTrainGroup)
# DataTrain <- as.data.frame(DataTrain)
# DataTrain$usedTrainGroup <- as.factor(DataTrain$usedTrainGroup)
# levels(DataTrain$usedTrainGroup) <- c("unComplicated", "Complicated")
#
# # MAke a violin plot
# library(tidyr)
#
# X <- pivot_longer(
#   DataTrain,
#   cols = 1:28,
#   names_to = "Gene",
#   names_repair = "check_unique",
#   values_to = "Expression",
# )
#
# png(filename = "./Figs/ComViolinPlot.png", width = 2000, height = 1200, res = 150)
# ggplot(X,
#        aes(x = usedTrainGroup,
#            y = Expression)) +
#   geom_violin(aes(fill = usedTrainGroup),
#               scale = "count")+
#   #geom_jitter(width = 0.1, size = 0.2)+
#   facet_wrap(~Gene)
# dev.off()
# set.seed(333)
# tuneRF(x = PredictorData_Filt, y = usedTrainGroup, mtryStart = 1, ntreeTry = 500, stepFactor = 1, improve = 0.01, trace = F, plot = F)
#
# set.seed(333)
# RF <- randomForest(usedTrainGroup~., data = DataTrain, mtry = 1, ntree = 500, trace = F, plot = F, doBest = T, sampsize = sampsizes, importance = T)
# RF
#
# explain_forest(RF, interactions = TRUE, data = DataTrain)
##################################
## Build the random forest model
set.seed(333)
RF_Comp <- tuneRF(x = PredictorData_Filt, y = usedTrainGroup, mtryStart = 1, ntreeTry=500, stepFactor = 1, improve=0.05, trace=F, plot=F, doBest=T, sampsize = sampsizes)
RF_Comp
# treeList <- RF2List(RF_Comp)  # transform rf object to an inTrees' format
# exec <- extractRules(treeList, PredictorData_Filt)  # R-executable conditions
# exec[1:2,]
#
# ruleMetric <- getRuleMetric(exec,PredictorData_Filt,usedTrainGroup)  # get rule metrics
# ruleMetric[1:2,]
#
# readableRules <- presentRules(ruleMetric, colnames(PredictorData_Filt))
# readableRules[1:2, ]
#
# freqPattern <- getFreqPattern(ruleMetric)
# Save the model
#save(RF_Comp, file = "./Objs/RF_Comp.rda")
load("./Objs/RF_Comp.rda")
################
# Predict in the training data
PredVotes_Train <- predict(RF_Comp, newdata = PredictorData_Filt, type = "vote")
PredResponse_Train <- predict(RF_Comp, PredictorData_Filt, type="response")
ROCTrain <- roc(usedTrainGroup, PredVotes_Train[,2], plot = F, print.auc = TRUE, levels = c("unComplicated", "Complicated"), direction = "<", col = "blue", lwd = 2, grid = TRUE, auc = TRUE, ci = TRUE)
ROCTrain
confusion_test <- confusionMatrix(PredResponse_Train, usedTrainGroup, positive = "Complicated")
confusion_test
# Calculate Matthews correlation coefficient
MCC_Train <- mcc(preds = PredResponse_Train, actuals = usedTrainGroup)
MCC_Train
#################
## Predict in the testing data
PredVotes_Test <- predict(RF_Comp, newdata = TestingData_Filt, type = "vote")
PredResponse_Test <- predict(RF_Comp, TestingData_Filt, type="response")
ROCTest <- roc(usedTestGroup, PredVotes_Test[,2], plot = F, print.auc = TRUE, levels = c("unComplicated", "Complicated"), direction = "<", col = "blue", lwd = 2, grid = TRUE, auc = TRUE, ci = TRUE)
ROCTest
### Resubstitution peRF_Compormance in the Test set
ConfusionTest <- confusionMatrix(PredResponse_Test, usedTestGroup, positive = "Complicated", mode = "everything")
ConfusionTest
MCC_Test <- mltools::mcc(pred = PredResponse_Test, actuals = usedTestGroup)
MCC_Test
Sel
load("/Users/mohamedomar/Dropbox (MechPred)/MechPred/USER/Mohamed/MechanisticModels/Prostate/Data/Dataset6.rda")
View(Dataset6)
